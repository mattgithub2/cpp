\documentclass{report}

\input{~/latex/template/preamble.tex}
\input{~/latex/template/macros.tex}

\title{\Huge{Logs}}
\author{\huge{Matt Warner}}
\date{\huge{}}
\pagestyle{fancy}
\fancyhf{}
\rhead{}
\lhead{\leftmark}
\cfoot{\thepage}
% \usepackage[default]{sourcecodepro} \usepackage[T1]{fontenc}

\pgfpagesdeclarelayout{boxed}
{
  \edef\pgfpageoptionborder{0pt}
}
{
  \pgfpagesphysicalpageoptions
  {%
    logical pages=1,%
  }
  \pgfpageslogicalpageoptions{1}
  {
    border code=\pgfsetlinewidth{1.5pt}\pgfstroke,%
    border shrink=\pgfpageoptionborder,%
    resized width=.95\pgfphysicalwidth,%
    resized height=.95\pgfphysicalheight,%
    center=\pgfpoint{.5\pgfphysicalwidth}{.5\pgfphysicalheight}%
  }%
}

\pgfpagesuselayout{boxed}

\begin{document}
    \maketitle
    \section{8/10/24}
    \subsection{Operator overload returns} 
    Say we had the following code:
    \begin{minted}[linenos=false]{cpp}
    vec1 = vec2;
    \end{minted}
    \noindent Inside the body of the overloaded \texttt{operator=} function, we are copying over the internal state of the right operand to the object on the left side of \texttt{operator=} (\texttt{this}). Internally, it might look like this:
    \begin{minted}[linenos=false]{cpp}
    if (this != &rhs)  {

        delete[] data;
        m_size = rhs.m_size;
        m_capacity = rhs.m_capacity

        std::copy(rhs.begin(), rhs.end(), data);
        return *this;
    }
    \end{minted}
    But why do we need to return \texttt{*this?} If we are just copying data to our current object, why not just use void?
    \bigbreak \noindent
    The reason why we return \texttt{*this} is simple, returning \texttt{*this} allows for \textbf{chaining operations}. Like this:
    \begin{minted}[linenos=false]{cpp}
    vec1 = vec2 = vec3;
    \end{minted}
Hereâ€™s how it works:

\begin{itemize}
    \item vec2 = vec3 calls the assignment operator, which modifies vec2 and returns *this (which is now vec2).
    \item The result of vec2 = vec3 is then assigned to vec1, calling the assignment operator again, this time for vec1.
\end{itemize} \noindent
Without returning *this, you cannot chain assignments in this manner. If operator= returned void, the assignment vec1 = vec2 = vec3 would not work as expected because the intermediate result (the updated vec2) would not be usable for further assignments.
\bigbreak \noindent
Therefore, you should return *this whenever writing \texttt{operator overloads} that can be chained together. These are:
\begin{itemize}
    \item \texttt{operator=}
    \item \texttt{operator+=}
    \item \texttt{operator-=}
    \item \texttt{operator-}
    \item \texttt{operator+}
    \item \texttt{operator++}
    \item \texttt{operator--}
\end{itemize}
\noindent Furthermore, consider these:
\begin{minted}[linenos=false]{cpp}
    it1 = it2 - it3;
    it2 = ++it3;

    // perhaps even this one
    it2 = ++(++it3);
\end{minted}
\noindent These examples would not be possible without returning the modified object.
    \subsection{pointer arithmetic}
    Say we had a pointer to a dynamically allocated array:
    \begin{minted}[linenos=false]{cpp}
    int* x = new int[5];
    
    // Filling the array
    int* ptr = x;
    for (; ptr < x+5; ++ptr) {
        *ptr = 1;
    }
    \end{minted}
    We can use pointer arithmetic to jump to positions in the array like so:
    \begin{minted}[linenos=false]{cpp}
int* ptr2 = x + 2;  // Moves the pointer to the third element of the array
ptr = (x + 2) - 2;  // Moves the pointer back to the start of the array
ptr += 2;           // Moves the pointer forward by 2 positions (to the third element)
ptr -= 2;           // Moves the pointer back by 2 positions (to the start of the array)
    \end{minted}
    However, there are some invalid operations to consider:
    \begin{minted}[linenos=false]{cpp}
ptr += ptr2;   // Not allowed: adding two pointers
ptr = ptr + ptr2; // Not allowed: adding a pointer and another pointer
ptr-=ptr2; // also not allowed

    \end{minted} \noindent
You cannot add two pointers together because it does not make sense in terms of pointer arithmetic. Pointers represent positions in memory, and adding them does not yield a meaningful result.
\bigbreak \noindent
Furthermore, subtracting two pointers yields a distance of type \texttt{ptrdiff\_t}
\begin{minted}[linenos=false]{cpp}
    auto distance = ptr - ptr2;  // yields the distance between two pointers
\end{minted}
\subsection{adding typename to typedefs}
In C++, whenever you are creating typedefs for types that require template parameters, you need to add the keyword \texttt{typename}. For example, if you had an iterator for your vector class:
\begin{minted}[linenos=false]{cpp}
    template <class vector>
    class vector_iterator  {
    public:
        typedef typename vector::value_type value_type; // typename required
        typedef value_type* pointer; // no typename needed
    };
\end{minted}
\subsection{\texttt{This()} memeber function}
When designing a class, we can throw in the following function:
\begin{minted}[linenos=false]{cpp}
class x {
public:
    x* This() { return this; }
};

    
\end{minted}
This gives us a way to get a pointer to an object:
\begin{minted}[linenos=false]{cpp}
x obj;
x* = obj.this();
\end{minted}
This is usually not neccassary to do but it might be worth knowing.
\section{8/17/24}
\subsection{Variadic Templates}
In C, we could can use ellipses ($\ldots$) to allow functions to accept an arbitrary number of parameters.
\begin{minted}[linenos=false]{c}
    void foo(int x,char...);
\end{minted}
Modern C++ adds a feature known as \textbf{variadic templates}, which can be seen when a template has a parameter pack in its parameter list. The syntax looks like this:
\begin{minted}[linenos=false]{cpp}
template <typename... Args>
void foo(Args... args);
\end{minted}
A template with at least one parameter pack is called a \textbf{variadic template}.
\bigbreak \noindent
A variadic class template can be instantiated with any number of template arguments:
\begin{minted}[linenos=false]{cpp}
template<typename.. Types>
struct Tuple {};

Tuple<> t0;             // Types contains no arguments
Tuple<int> t1;          // Types contains one argument: int
Tuple<int,float> t2;    // Types contains two arguments: int and float
Tuple<0> t3;            // Error: 0 is not a type
\end{minted}
\bigbreak \noindent
A variadic function template can be called with any number of function arguments (the template arguments are deduced through template argument deduction).
\begin{minted}[linenos=false]{cpp}
template <typename... Types>
void f(Types... args);

f();        // OK: args contains no arguments.
f(1);      // OK: args contains one argument: int
f(2,1.0); // OK: args contains two arguments: int and double
\end{minted}
In a primary class template, the \textbf{template parameter pack} must be the final parameter in the template parameter list. In a function template, the template parameter pack may appear earlier in the list provided that all following parameters can be deduced from the function arguments, or have default arguments.
\begin{minted}[linenos=false]{cpp}
template <typename U, typename... Ts>
struct valid; // OK: can deduce U

template <typename... Ts, typename U>
struct invalid; // Error: Ts... Not at the end

template <typename... Ts, typename U, typename=void>
void valid(U, Ts...);       // OK: can deduce U
// Void valid(Ts..., U);    // Can't be used: Ts... is a non-deduced context in this position

valid(1.0, 1, 2, 3);        // OK: deduces U as double, Ts as {int, int, int}
\end{minted}
If every valid specialization of a variadic template requires an empty template parameter pack, the program is ill-formed. no diagnostic required.
\subsubsection{Pack expansion}
A pattern followed by an ellipsis, in which the name of at least one parameter pack appears at least once, is \textit{expanded} into zero or more instantiations of the pattern, where the name of the parameter pack is replaced by each of the elements from the pack, in order. Instantiations of \textbf{allignment specifiers} are space-separated, other instantiations are comma-seperated.
\begin{minted}[linenos=false]{cpp}
template <typename... Us>
void f(Us... pargs) {}
template<typename... Ts>
void g(Ts... args) {
    f(&args...);        // "&args..." is a pack expansion
                        // "&args" is its pattern
}
\end{minted}
If the names of two parameter packs appear in the same pattern, they are expanded simultaneously, and they must have the same length:
\begin{minted}[linenos=false]{cpp}
template<typename...>
struct Tuple {};

template<typename T1, typename T2>
struct Pair {};

template<typename... Args1>
struct zip {
    template<typename... Args2>
    struct with {
        typedef Tuple<Pair<Args1, Args2>...> type;
        
    };
};
\end{minted}
\subsubsection*{Printing w/ template packs}
If you are using C++17 or later, there is a feature called \textbf{fold expressions} that make it very simple to print your parameter packs.
\begin{minted}[linenos=false]{cpp}
// Variadic template function to print multiple arguments
template<typename... Args>
void print(Args... args) {
(std::cout << ... << (args, " ")) << std::endl;
}
\end{minted}
Without C++17, recursion must be used. This means that we need a base case with zero arguments, and a recursive case with 1 explcit argument and a tail consisting of a variadic list of arguments.
\begin{minted}[linenos=false]{cpp}
// Base case with 0 arguments
void print(){
std::cout << std::endl;
}
// Recursive case
template<typename Tp, typename... Args>
void print(Tp const &head, const &Args... tail) {
    std::cout << head;
    if (sizeof...(tail)) {
        std::cout << ", ";
    }
    print(tail...);
}
\end{minted}
\nt {
    the \texttt{sizeof... operator} Queries the number of elements in a \texttt{parameter pack}
}
\subsubsection*{Example for std::vector's emplace}
When implementing \texttt{emplace()} for your vector class, You should be using \textbf{variadic templates} in order to give the constructor all the members of the type. Therefore, your emplace function might look like this:
\begin{minted}[linenos=false]{cpp}
template <typename it, typename... Args>
iterator vector::emplace(it&& position, Args&&... args) {
    // Check for full container
    if (size == capacity) {
        (capacity) ? reserve(capacity * 2) : reserve(1);
    }
    
    ptrdiff_t offset = position - begin();

    // Move all the elements to the right
    for (ptrdiff_t i = static_cast<ptrdiff_t>(m_size); i > offset; --i) {
        m_data[i] = m_data[i - 1];
    }
    // Using placement new
    new (m_data + offset) value_type(std::forward<Args>(args)...);
    ++m_size;
    position = m_data + offset;

    return position;

}
// Calling emplace.
struct items{
    int x;
    double y;
    char k;

    items(int x=0, double y=0, char k='F') : x(x), y(y), k(k);
};
vector<items> vec{1,2,3,4};
vec.emplace(1,2.0, 'a');
\end{minted}
Now, we can call emplace with the precise amount of data to match our types data members.

\end{document}
